# Load necessary libraries
library(CovTools) 
library(lsbclust)
library(shapes)
library(ICtest)
library(ggplot2)
library(dplyr)
library(parallel)
library(purrr)


### This is a way to generate data (corr and Cov)

generate_matrices <- function(sample_size,dim,mu,sig) {
  
  replicate(sample_size, {
    
    U <- rorth(dim)
    D <- diag(exp(rnorm(dim,mu,sig)))
    S <- U%*%D%*%t(U)
    
    ## if you want to generate corr matrices, then run the code lines below
    # diagS <- diag(S)
    # diag(1/sqrt(diagS))%*%S%*%diag(1/sqrt(diagS))
    
  })
  
}

matrices <- generate_matrices(5,3,0,1)



# Step 2: Compute average squared distance using distcov
average_squared_distances <- function(matrices) {
  n <- dim(matrices)[3]
  sapply(1:n, function(i) {
    mean(sapply(1:n,
                function(j) if (i != j) distcov(matrices[, , i],
                                                matrices[, , j],
                                                method ='LogEuclidean')^2 else 0))
  })
}



# Step 3: Invert all generated matrices
invert_matrices <- function(matrices) {
  n <- dim(matrices)[3] # Number of matrices
  dim <- dim(matrices)[1] # Dimension of each matrix
  inverted_matrices <- array(0, dim = c(dim, dim, n)) # Create an empty 3D array
  for (i in 1:n) {
    inverted_matrices[, , i] <- solve(matrices[, , i]) # Invert each matrix
  }
  return(inverted_matrices)
}

# Step 4: Compute average squared distance for inverted matrices
average_squared_distances_inverted <- function(matrices) {
  iverted_matrices <- invert_matrices(matrices)
  n <- dim(matrices)[3]
  sapply(1:n, function(i) {
    mean(sapply(1:n, function(j) distcov(matrices[, , i], iverted_matrices[, , j],
                                         method ='LogEuclidean')^2))
  })
}




# --------------------------------------------------------
# Function to compute skewness
# --------------------------------------------------------

metric_skew_fun <- function(matrices) {
  
  # Step 2: Compute average squared distance for original matrices
  avg_dist_original <- average_squared_distances(matrices)
  
  
  # Step 3: Compute average squared distance for inverted matrices
  avg_dist_inverted <- average_squared_distances_inverted(matrices)
  
  # Step 4: Compute the final average squared distance
  final_avg_distance <- mean((avg_dist_original - avg_dist_inverted)^2)/mean(avg_dist_original^2)
  
  # Return results
  return(Metric_skewness = final_avg_distance)
}




Perm_test <- function(matrices, iter, seed, regularize){
  
  
  set.seed(seed)
  
  
  
  # Compute the observed Metric Skewness
  T0 <- metric_skew_fun(matrices)
  
  n <- dim(matrices)[3]
  Tperm <- numeric(iter)
  
  for(b in 1:iter) {
    # random flips: TRUE = invert, FALSE = keep
    flips <- sample(c(TRUE, FALSE), n, replace = TRUE)
    perm_sample <- array(0, dim = dim(matrices))
    for(i in 1:n) {
      if(flips[i]) {
        A <- matrices[,,i]
        if(regularize > 0) A <- A + regularize * diag(dim(generate_matrices(sample_size, dim, mu, sig))[1])
        perm_sample[,,i] <- solve(A)
      } else {
        perm_sample[,,i] <- matrices[,,i]
      }
    }
    Tperm[b] <- metric_skew_fun(perm_sample)
  }

  
  
  
  pval <- mean(abs(Tperm) >= abs(T0))
  
  result <-list(statistic = T0, p.value = pval, Tperm = Tperm)
  names(result) <- c("observed statistic","p_value", "permutation stats")
  result
}


Perm_test(matrices,20,2,0)


# -----------------------------
# 6) Simulation across sample sizes to estimate level
# -----------------------------
estimate_level_over_nsamples <- function(sample_sizes,
                                         dim,
                                         mu, sig,
                                         nrep, iter,
                                         alpha,
                                         regularize,
                                         seed) {
  proportions <- numeric(length(sample_sizes))
  for(k in seq_along(sample_sizes)) {
    n <- sample_sizes[k]
    rejections <- 0
    for(rep in 1:nrep) {
      mat <- generate_matrices(n, dim, mu, sig)
      test <- Perm_test(mat, iter, seed, regularize)
      if(test$p_value < alpha) rejections <- rejections + 1
    }
    proportions[k] <- rejections / nrep
    cat(sprintf("n=%d  -> rejection prop = %.3f\n", n, proportions[k]))
  }
  list(sample_sizes = sample_sizes, proportions = proportions)
}






# -----------------------------
# 7) Run a small experiment (example)
# -----------------------------
seed <- set.seed(2025)
sample_sizes <- seq(10, 200, by = 20)
sample_sizes <- c(2,5,10,20)

res <- estimate_level_over_nsamples(sample_sizes,
                                    dim = 2,
                                    mu = 0, sig = 1,
                                    nrep = 100,   # raise to 200+ for stable estimates
                                    iter = 100,    # increase B for smoother p-values
                                    alpha = 0.05,
                                    regularize = 0,
                                    seed)

# -----------------------------
# 8) Plot results
# -----------------------------
plot(res$sample_sizes, res$proportions, type = "b", pch = 19,
     xlab = "Sample size (number of matrices)",
     ylab = "Proportion p < alpha",
     main = "Level of permutation inversion test (mu = 0)")
abline(h = 0.05, col = "red", lty = 2)









